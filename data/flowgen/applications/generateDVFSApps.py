import AppComposer
import PlatformComposer
from fractions import Fraction

# This script generate DVFS AppComposer Applications for a given network topology and router-grained previously computed clock frequencies.
def generateDVFSApps(Platform, PlatformName, RouterClockFrequencies, BusClockFrequencies, CrossbarClockFrequencies, GenRouterGrained = True, GenStructGrained = True, GenGlobalGrained = True, GenStaticClocked = True, InputClockFrequency = 250, QuantumTime = 1000000, SaveToFile = True, ReturnAsJSON = False):
        
    if not isinstance(Platform, PlatformComposer.Platform):
        print("Error: Object given as Platform parameter is not of PlatformComposer.Platform class")
        exit(1)
        
    # Sets up return dict, containing all Application generated by this script
    AppDict = {"RouterGrained": None, "StructGrained": None, "GlobalGrained": None, "StaticClocked": None}
        
    # TODO: Check if not standalone struct
    
    # Extract base parameters from given Platform object. 
    AmountOfRouters = Platform.BaseNoCDimensions[0] * Platform.BaseNoCDimensions[1]
    AmountOfBuses = Platform.AmountOfBuses
    AmountOfCrossbars = Platform.AmountOfCrossbars
    AmountOfPEs = Platform.AmountOfPEs
    DVFSServiceID = Platform.DVFSServiceID  # 32 bit constant as hex
    DVFSCounterResolution = Platform.DVFSCounterResolution 
    # TODO: Do search for BusID/CrossbarID of first PEPos in struct here
    
    #MaxFrequency = 250  # in MHz
    #Resolution = 15  # in bits
    #QuantumTime = 1000000  # 1 ms in nanoseconds
    
    # Check if amount of Quantums is coherent for each clock frequency list
    if BusClockFrequencies is not None:

        if len(RouterClockFrequencies) == len(BusClockFrequencies):
            AmountOfQuantums = len(RouterClockFrequencies)
        else:
            print("Error: Incoherent amount of quantums: Per Router <" + str(len(RouterClockFrequencies)) + "> Per Bus <" + str(len(BusClockFrequencies))+ ">")
            exit(1)

    if CrossbarClockFrequencies is not None:

        if len(RouterClockFrequencies) == len(CrossbarClockFrequencies):
            AmountOfQuantums = len(RouterClockFrequencies)
        else:
            print("Error: Incoherent amount of quantums: Per Router <" + str(len(RouterClockFrequencies))+ "> Per Crossbar <" + str(len(CrossbarClockFrequencies)) + ">")
            exit(1)
    
    AmountOfQuantums = len(RouterClockFrequencies)
        
    # Check if amount of routers or PEs in Bus/Crossbars are coherent with info from Platform object
    for i, ClocksInQuantum in enumerate(RouterClockFrequencies):
        if len(ClocksInQuantum) != AmountOfRouters:
            print("Error: Amount of Routers = <" + str(len(ClocksInQuantum)) + "> for Quantum <" + str(i) + "> differs from amount of Routers from Platform object <" + str(AmountOfRouters) + ">")
            exit(1)
            
    if BusClockFrequencies is not None: 
        for i, ClocksInQuantum in enumerate(BusClockFrequencies):
            if len(ClocksInQuantum) != AmountOfBuses:
                print("Error: Amount of Buses = <" + str(len(ClocksInQuantum)) + "> for Quantum <" + str(i) + "> differs from amount of Buses from Platform object <" + str(AmountOfBuses) + ">")
                exit(1)

    if CrossbarClockFrequencies is not None:            
        for i, ClocksInQuantum in enumerate(CrossbarClockFrequencies):
            if len(ClocksInQuantum) != AmountOfCrossbars:
                print("Error: Amount of Crossbars = <" + str(len(ClocksInQuantum)) + "> for Quantum <" + str(i) + "> differs from amount of Crossbars from Platform object <" + str(AmountOfCrossbars) + ">")
                exit(1)

    # Clock frequencies per router + per bus + per crossbar, per Workload
    #ClockFrequenciesBB = [48, 32, 0, 45, 15, 16, 16, 30, 75, 30, 48, 24, 32, 45, 23.625, 48, 24, 48, 23.785, 12.215, 24, 24, 24, 48, 16] + [24, 17.75875]  # Workload BB, frequency in MHz
    #ClockFrequenciesMM = [30, 51.4275, 0, 24.4275, 24.4275, 90, 150, 0, 90, 47.57, 22.82, 90, 0, 22.5, 22.82, 47.57, 90, 0, 150, 90, 24.4275, 24.4275, 0, 51.2475, 30] + [23.3025, 23.3025]  # Workload MM, frequency in MHz
    #ClockFrequenciesAA = [197.5, 230.375, 62.5, 230.375, 197.5, 224.125, 115.375, 62.5, 84.125, 224.125, 63, 80, 12.25, 80, 71, 17.5, 102.75, 72.5, 98.25, 148.5, 90.5, 90.5, 93.25, 88.25, 200] + [36.5, 38.5]  # Workload AA, frequency in MHz
    #ClockFrequenciesHH = [197.5, 230.375, 62.5, 90, 30, 224.125, 115.375, 60, 150, 60, 63, 80, 0, 30, 47.25, 48, 16, 16, 47.57, 23.6775, 32, 16, 16, 32, 16] + [36.5, 35.5175] # Workload HH, frequency in MHz
    #ClockFrequencies = [ClockFrequenciesBB, ClockFrequenciesMM, ClockFrequenciesAA, ClockFrequenciesHH]

    if GenRouterGrained:
    
        # Make Application
        DVFSApp = AppComposer.Application(AppName = "DVFSApp", StartTime = 0, StopTime = 0)

        # Make Threads
        DVFSMaster = AppComposer.Thread(ThreadName = "Master")
        DVFSSlaves = [AppComposer.Thread(ThreadName = "Slave" + str(i)) for i in range(0, AmountOfPEs)]

        # Add Threads to applications
        DVFSApp.addThread(DVFSMaster)
        for DVFSSlave in DVFSSlaves:
            DVFSApp.addThread(DVFSSlave)
        
        for Quantum in range(AmountOfQuantums):
            for PEPos, PE in enumerate(Platform.PEs):
            
                # Only NoC and first-of-struct PEs are needed (no DVFS for PEs inside Bus/Crossbar)
                if PE.CommStructure != "NoC" and PE.StructPos != 0:
                    continue
                
                # Determines N and M (numerator and denominator) on config flit
                if PE.CommStructure == "NoC":
                
                    DivRatio = Fraction(RouterClockFrequencies[Quantum][PE.BaseNoCPos] / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    
                elif PE.CommStructure == "Bus":
                
                    BusID = None
                    
                    # Finds which Bus this PE is in
                    for i, Bus in enumerate(Platform.Buses):

                        if Bus.PEs[0].PEPos == PEPos:
                            BusID = i
 
                    try:
                        DivRatio = Fraction(BusClockFrequencies[Quantum][BusID] / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    except TypeError:
                        print("Error: Cant find a BusID for PEPos <" + str(PEPos) + ">")
                        exit(1)
                        
                elif PE.CommStructure == "Crossbar":
                    
                    CrossbarID = None
                            
                    # Finds which Crossbar this PE is in        
                    for i, Crossbar in enumerate(Platform.Crossbars):

                        if Crossbar.PEs[0].PEPos == PEPos:
                            CrossbarID = i

                    try:
                        DivRatio = Fraction(CrossbarClockFrequencies[Quantum][CrossbarID] / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    except TypeError:
                        print("Error: Cant find a CrossbarID for PEPos <" + str(PEPos) + ">")
                        exit(1)
                        
                else:
                    print("Error: Invalid CommStructure value <" + str(PE.CommStructure) + "> for PE <" + str(PEPos) + ">. Acceptable values are [NoC, Bus, Crossbar].")
                
                # Determines power switch enable signal on config flit
                SupplySwitchBit = '1' if DivRatio > Fraction(1, 2) else '0' 
                    
                # Determine IsNoC bit on config flit
                IsNoCBit = '1' if PE.CommStructure == "NoC" else '0'
                    
                # Determines config flit for DVFS Payload
                ConfigFlit = SupplySwitchBit + IsNoCBit + format(DivRatio.numerator, "0" + str(DVFSCounterResolution) + "b") + format(DivRatio.denominator, "0" + str(DVFSCounterResolution) + "b")
                ConfigFlit = '%0*X' % ((len(ConfigFlit) + 3) // 4, int(ConfigFlit, 2))  # Converts bit string to hex string "https://stackoverflow.com/questions/2072351/python-conversion-from-binary-string-to-hexadecimal"

                # DEBUG
                #print("Ratio: " + str(DivRatio.numerator) + " by " + str(DivRatio.denominator))
                #print("N as binary: " + format(DivRatio.numerator, "0" + str(DVFSCounterResolution) + "b"))
                #print("M as binary: " + format(DivRatio.denominator, "0" + str(DVFSCounterResolution) + "b"))
                    
                # Adds Flow with custom Payload to master DVFS Thread
                DVFSMaster.addFlow(AppComposer.Flow(TargetThread = DVFSSlaves[PEPos], Bandwidth = 128000, StartTime = Quantum * QuantumTime, MSGAmount = 1, Payload = [DVFSServiceID, ConfigFlit]))
        
        # Add DVFS to AppDict
        if ReturnAsJSON:
            AppDict["RouterGrained"] = DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppRouterGrained" + str(PlatformName)) 
        else:
            AppDict["RouterGrained"] = DVFSApp
                    
        # Write Router-grained DVFS Application to a JSON file
        DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppRouterGrained" + str(PlatformName))

    # Generates Struct-grained DVFS App (Whole NoC + All Buses + All Crossbars). Skipped if standalone NoC (no Bus/Crossbars)    
    if GenStructGrained and (AmountOfCrossbars > 0 or AmountOfBuses > 0):
        
        # Make Application
        if SaveToFile:
            DVFSApp = AppComposer.Application(AppName = "DVFSApp", StartTime = 0, StopTime = 0)

        # Make Threads
        DVFSMaster = AppComposer.Thread(ThreadName = "Master")
        DVFSSlaves = [AppComposer.Thread(ThreadName = "Slave" + str(i)) for i in range(0, AmountOfPEs)]

        # Add Threads to applications
        DVFSApp.addThread(DVFSMaster)
        for DVFSSlave in DVFSSlaves:
            DVFSApp.addThread(DVFSSlave)
        
        for Quantum in range(AmountOfQuantums):
            for PEPos, PE in enumerate(Platform.PEs):
            
                # Only NoC and first-of-struct PEs are needed (no DVFS for PEs inside Bus/Crossbar)
                if PE.CommStructure != "NoC" and PE.StructPos != 0:
                    continue
                
                # Determines N and M (numerator and denominator) on config flit
                if PE.CommStructure == "NoC":
                
                    # Max Router clock defines all other Routers'
                    DivRatio = Fraction(max(RouterClockFrequencies[Quantum]) / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    
                elif PE.CommStructure == "Bus":
                
                    BusID = None
                    
                    # Finds which Bus this PE is in
                    for i, Bus in enumerate(Platform.Buses):
                        if Bus.PEs[0].PEPos == PEPos:
                            BusID = i
                            
                    try:
                        DivRatio = Fraction(BusClockFrequencies[Quantum][BusID] / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    except TypeError:
                        print("Error: Cant find a BusID for PEPos <" + str(PEPos) + ">")
                        exit(1)
                        
                elif PE.CommStructure == "Crossbar":
                    
                    CrossbarID = None
                            
                    # Finds which Crossbar this PE is in        
                    for i, Crossbar in enumerate(Platform.Crossbars):
                        if Crossbar.PEs[0].PEPos == PEPos:
                            CrossbarID = i
                            
                    try:
                        DivRatio = Fraction(CrossbarClockFrequencies[Quantum][CrossbarID] / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                    except TypeError:
                        print("Error: Cant find a BusID for PEPos <" + str(PEPos) + ">")
                        exit(1)
                        
                else:
                    print("Error: Invalid CommStructure value <" + str(PE.CommStructure) + "> for PE <" + str(PEPos) + ">. Acceptable values are [NoC, Bus, Crossbar].")
                
                # Determines power switch enable signal on config flit
                SupplySwitchBit = '1' if DivRatio > Fraction(1, 2) else '0' 
                    
                # Determine IsNoC bit on config flit
                IsNoCBit = '1' if PE.CommStructure == "NoC" else '0'
                    
                # Determines config flit for DVFS Payload
                ConfigFlit = SupplySwitchBit + IsNoCBit + format(DivRatio.numerator, "0" + str(DVFSCounterResolution) + "b") + format(DivRatio.denominator, "0" + str(DVFSCounterResolution) + "b")
                ConfigFlit = '%0*X' % ((len(ConfigFlit) + 3) // 4, int(ConfigFlit, 2))  # Converts bit string to hex string "https://stackoverflow.com/questions/2072351/python-conversion-from-binary-string-to-hexadecimal"
                    
                # Adds Flow with custom Payload to master DVFS Thread
                DVFSMaster.addFlow(AppComposer.Flow(TargetThread = DVFSSlaves[PEPos], Bandwidth = 128000, StartTime = Quantum * QuantumTime, MSGAmount = 1, Payload = [DVFSServiceID, ConfigFlit]))
                
        # Add DVFS to AppDict
        if ReturnAsJSON:
            AppDict["StructGrained"] = DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppStructGrained" + str(PlatformName)) 
        else:
            AppDict["StructGrained"] = DVFSApp
            
        # Write struct-grained DVFS Application to a JSON file
        if SaveToFile:
            DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppStructGrained" + str(PlatformName))
        
    #   
    if GenGlobalGrained:
        
        # Make Application
        DVFSApp = AppComposer.Application(AppName = "DVFSApp", StartTime = 0, StopTime = 0)

        # Make Threads
        DVFSMaster = AppComposer.Thread(ThreadName = "Master")
        DVFSSlaves = [AppComposer.Thread(ThreadName = "Slave" + str(i)) for i in range(0, AmountOfPEs)]

        # Add Threads to applications
        DVFSApp.addThread(DVFSMaster)
        for DVFSSlave in DVFSSlaves:
            DVFSApp.addThread(DVFSSlave)
        
        for Quantum in range(AmountOfQuantums):
            for PEPos, PE in enumerate(Platform.PEs):
            
                # Only NoC and first-of-struct PEs are needed (no DVFS for PEs inside Bus/Crossbar)
                if PE.CommStructure != "NoC" and PE.StructPos != 0:
                    continue
                
                # Determines N and M (numerator and denominator) on config flit
                NoCMaxFreq = max(RouterClockFrequencies[Quantum])
                try:
                    BusMaxFreq = max(BusClockFrequencies[Quantum])
                except (ValueError, TypeError):  # BusClockFrequencies is an empty list (ValueError) or None (TypeError)
                    BusMaxFreq = 0
                
                try:
                    CrossbarMaxFreq = max(CrossbarClockFrequencies[Quantum])
                except (ValueError, TypeError):  # CrossbarClockFrequencies is an empty list (ValueError) or None (TypeError)
                    CrossbarMaxFreq = 0
                    
                MaxClockFreq = max(NoCMaxFreq, BusMaxFreq, CrossbarMaxFreq)
                DivRatio = Fraction(MaxClockFreq / InputClockFrequency).limit_denominator(2**DVFSCounterResolution)
                
                # Determines power switch enable signal on config flit
                SupplySwitchBit = '1' if DivRatio > Fraction(1, 2) else '0' 
                    
                # Determine IsNoC bit on config flit
                IsNoCBit = '1' if PE.CommStructure == "NoC" else '0'
                    
                # Determines config flit for DVFS Payload
                ConfigFlit = SupplySwitchBit + IsNoCBit + format(DivRatio.numerator, "0" + str(DVFSCounterResolution) + "b") + format(DivRatio.denominator, "0" + str(DVFSCounterResolution) + "b")
                ConfigFlit = '%0*X' % ((len(ConfigFlit) + 3) // 4, int(ConfigFlit, 2))  # Converts bit string to hex string "https://stackoverflow.com/questions/2072351/python-conversion-from-binary-string-to-hexadecimal"
                    
                # Adds Flow with custom Payload to master DVFS Thread
                DVFSMaster.addFlow(AppComposer.Flow(TargetThread = DVFSSlaves[PEPos], Bandwidth = 128000, StartTime = Quantum * QuantumTime, MSGAmount = 1, Payload = [DVFSServiceID, ConfigFlit]))
                
        # Add DVFS to AppDict
        if ReturnAsJSON:
            AppDict["GlobalGrained"] = DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppGlobalGrained" + str(PlatformName)) 
        else:
            AppDict["GlobalGrained"] = DVFSApp
            
        # Write global-grained DVFS Application to a JSON file
        if SaveToFile:
            DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppGlobalGrained" + str(PlatformName))    
        
    # TODO: Skip if standalone NoC (no Bus/Crossbars)    
    if GenStaticClocked:
        
        # Make Application
        DVFSApp = AppComposer.Application(AppName = "DVFSApp" + str(PlatformName), StartTime = 0, StopTime = 0)

        # Make Threads
        DVFSMaster = AppComposer.Thread(ThreadName = "Master")
        DVFSSlaves = [AppComposer.Thread(ThreadName = "Slave" + str(i)) for i in range(0, AmountOfPEs)]

        # Add Threads to applications
        DVFSApp.addThread(DVFSMaster)
        for DVFSSlave in DVFSSlaves:
            DVFSApp.addThread(DVFSSlave)
        
        for Quantum in range(AmountOfQuantums):
            for PEPos, PE in enumerate(Platform.PEs):
            
                # Only NoC and first-of-struct PEs are needed (no DVFS for PEs inside Bus/Crossbar)
                if PE.CommStructure != "NoC" and PE.StructPos != 0:
                    continue
                
                # Determines N and M (numerator and denominator) on config flit
                #DivRatio = Fraction(MaxFrequency).limit_denominator(Resolution)
                DivRatio = Fraction(1, 1).limit_denominator(2**DVFSCounterResolution)
                
                # Determines power switch enable signal on config flit
                SupplySwitchBit = '1' if DivRatio > Fraction(1, 2) else '0' 
                    
                # Determine IsNoC bit on config flit
                IsNoCBit = '1' if PE.CommStructure == "NoC" else '0'
                    
                # Determines config flit for DVFS Payload
                ConfigFlit = SupplySwitchBit + IsNoCBit + format(DivRatio.numerator, "0" + str(DVFSCounterResolution) + "b") + format(DivRatio.denominator, "0" + str(DVFSCounterResolution) + "b")
                ConfigFlit = '%0*X' % ((len(ConfigFlit) + 3) // 4, int(ConfigFlit, 2))  # Converts bit string to hex string "https://stackoverflow.com/questions/2072351/python-conversion-from-binary-string-to-hexadecimal"
                    
                # Adds Flow with custom Payload to master DVFS Thread
                DVFSMaster.addFlow(AppComposer.Flow(TargetThread = DVFSSlaves[PEPos], Bandwidth = 128000, StartTime = Quantum * QuantumTime, MSGAmount = 1, Payload = [DVFSServiceID, ConfigFlit]))
                
        # Add DVFS to AppDict
        if ReturnAsJSON:
            AppDict["StaticClocked"] = DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppStaticClocked" + str(PlatformName)) 
        else:
            AppDict["StaticClocked"] = DVFSApp
        
        # Write struct-grained DVFS Application to a JSON file
        if SaveToFile:
            DVFSApp.toJSON(SaveToFile = True, FileName = "DVFSAppStaticClocked" + str(PlatformName)) 

    # Return Dict containing all apps     
    return AppDict    
